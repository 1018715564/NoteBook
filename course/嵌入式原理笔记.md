# 嵌入式原理复习笔记

## 嵌入式系统的特点与组成⭐

嵌入式系统是以**应用**为中心、以**计算机技术**为基础，**软硬件可裁剪**，应用系统对**功能、可靠性、成本、体积、功耗和应用环境**有特殊要求的专用计算机系统。是将**应用程序、操作系统和计算机硬件**集成在一起的系统。

嵌入式系统具有专用性、实时性、代码固化、可靠性、操作系统、开发环境、知识集成等特点。

### 专用性

- 形式多样
- 功耗限制
- 低成本
- 环境相关性  

### 实时性

实时性的本质是任务处理所化费时间的可预测性，即任务需要在规定的时限内完成。

实时系统必须在规定的时间范围内正确地响应外部物理过程的变化。

嵌入式系统 ≠ 实时系统

实时分为：

1. 软实时，意味着如果没有满足指定的时间约束不会导致灾难性后果。
2. 硬实时，则会导致灾难性后果。

### 代码固化

嵌入式系统的目标代码通常固化在非易失性存储器中，如ROM、EPROM、EEPROM、NorFlash等。

系统资源受限是一部分原因，其他主要原因是为了提高系统的执行速度和系统的可靠性。

### 可靠性

硬件可靠性：如冗余备份

软件可靠性：软件质量保证

出错处理：如硬件看门狗电路

自动复位



### 组成结构

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20190915140035.png)

## 嵌入式系统的分类

1. 按嵌入式微处理器位数分类

   4、8、16、32、64位

2. 按实时性分类

   ![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20190915140810.png)

3. 按嵌入式软件结构分类

   ![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20190915140834.png)

### 软件结构

​		循环轮询(polling loop)是最简单的软件结构，程序依次检查系统的每个输入条件，如果条件成立就执行相应处理。

​		前后台(foreground/background)系统属于中断驱动机制。后台程序是一个无限循环，通过调用函数实现相应操作，又称任务级。前台程序是中断处理程序，用来处理异步事件，又称中断级。设计前后台的目的主要是为了将时间性很强的关键操作(critical operation)通过中断服务来保证。通常情况下，中断只处理需要快速响应的事件，将输入/输出数据存放在内存的缓冲区里，再向后台发信号，由后台来处理这些数据，如运算、存储、显示、打印等。

​		多任务(multitasking)系统有利于降低系统的复杂度，保证系统的实时性和可维护性。
​		多任务系统的软件由多个任务、多个中断服务程序以及嵌入式操作系统组成。任务是顺序执行的，并行性通过操作系统完成。操作系统主要负责任务切换、任务调度、任务间以及任务与中断服务程序之间的通信、同步、互斥、实时时钟管理、中断管理等。

### 计算模式

与嵌入式系统密切相关的计算模式有：

1. 普适计算模式
2. 雾计算模式
3. 云计算模式
4. 分布式计算模式



## ARM处理器

### ARM体系结构

特点：

- 每条数据处理指令都对算术逻辑单元和移位器控制，实现了ALU和移位器的最大利用；
- 地址自动增加和减少寻址模式，优化程序循环；
- 多寄存器装在和存储指令实现最大数据吞吐量；
- 所有指令的条件执行实现最快速的代码执行。

ARM系列流水线操作：

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20191222155907.png)

ARM系列对比：

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20191222155934.png)

ARM9TDMI后缀意义：

- T：支持高密度16位Thumb指令集
- D：支持片上调试
- M：支持64位乘法
- I：支持Embeded-ICE观察硬件

## ARM指令集⭐

- 基于**精简指令集（RISC）**原理设计。
- 架构：**哈弗**
- 具有32位ARM指令集和16位Thumb指令集
- ARM指令集效率高，但是代码密度低
- Thumb指令集代码密度高，却仍然保持ARM的大多数性能上的优势，它是ARM指令集的子集。
- 所有ARM指令都是可以有条件执行的。
- ARM程序与Thumb程序可相互调用，状态切换开销几乎为零。

> [ARM指令合集（附带英文全称）](https://wenku.baidu.com/view/d8509322dd36a32d737581f7.html)⭐

### 指令格式

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20191222202734.png)

### 操作数

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20191222203107.png)

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20191222203128.png)

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20191222204156.png)

### 条件码

使用条件码“cond”可以实现高效的逻辑操作(节省跳转和条件语句)，提高代码效率。
所有的ARM指令都可以条件执行，而Thumb指令只有B（跳转）指令具有条件执行 功能。如果指令不标明条件代码，将默认为无条件（AL）执行。

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20191222203247.png)

Sample:

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20191222203404.png)

### 存储器访问指令⭐⭐⭐

ARM是RISC处理器，对存储器访问只能使用加载Load和存储Store指令实现。

RAM存储空间及I/O映射空间统一编制，除对RAM操作以外，对外围IO、程序数据的访问均要通过加载/存储指令进行。

存储器访问指令分：

- 单寄存器操作指令
- 多寄存器操作指令

#### 单寄存器加载LDR

Load Register

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20191222204604.png)

#### 单寄存器存储STR

STR：Store Register

STRB：Store Register Byte

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20191222204803.png)

LDR/STR指令用于对内存变量的访问、内存缓冲区数据的访问、查表、外围部件的控制操作等。若使用LDR指令加载数据到PC寄存器，则实现程序跳转功能，这样也就实现了程序散转。 

> 散转程序是分支程序的一种, 它可根据运算结果或用户输入数据将程序转入不同的分支。

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20191222215305.png)

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20191222215255.png)

Sample：

```assembly
LDR R1, [R0, #0x12] ;R0+0x12取此地址的值加载到R1

LDR R1, [R0, R2] ;R0+R2取此地址的值加载到R1

LDR R1, [R0, -R2] ;R0-R2取此地址的值加载到R1

LDR R1, [R0, R2, LSL #2] ;R0+R2*4取此地址的值加载到R1(LSL #2表示左移两位)
```

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20191222215211.png)

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20191222215239.png)

Sample：

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20191222215653.png)

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20191222215945.png)

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20191222220014.png)

#### 多存储器存取LDM/STM

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20191222220053.png)

多寄存器加载/存储指令可以实现在一组寄存器和一块连续的内存单元之间传输数据。LDM为加载多个寄存器；STM为存储多个寄存器。允许一条指令传送16个寄存器的任何子集或所有寄存器。它们主要用于**现场保护、数据复制、常数传递**等。

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20191222220148.png)

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20191222220332.png)

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20191222221643.png)

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20191223115315.png)

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20191223115343.png)

#### 寄存器与存储器交换指令SWP

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20191222221920.png)

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20191223101616.png)





### 数据处理指令

- 数据传送指令
- 算术逻辑运算指令
- 比较指令

数据处理指令只能对寄存器的内容进行操作，而不能对内存中的数据进行操作。

所有ARM数据处理指令均可选择使用S后缀，以使指令影响状态标志。

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20191223102550.png)

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20191223102603.png)

#### 数据传送指令

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20191223102621.png)

注：当后缀S时，这些指令根据结果更新标志N和Z，在计算Operand2时更新标志C，不影响标志V。

MOV: Move

MVN: Move NOT

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20191223103030.png)

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20191223103241.png)

#### 算术运算

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20191223103429.png)

注：这些指令影响N，Z，C和V标志位。

ADD: Add

SUB: Subtract

RSB: Reverse subtract

ADC: Add with carry

SBC: Subtract with carry

RSC: Reverse subtract with carry

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20191223103524.png)

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20191223103533.png)

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20191223103543.png)

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20191223103832.png)

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20191223104430.png)

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20191223105032.png)

#### 逻辑运算指令

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20191223105245.png)

注：当后缀S时，这些指令根据结果更新标志N和Z，在计算Operand2时更新标志C，不影响标志V。

AND and

ORR OR

EOR Exclusive OR

BLC Bit clear

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20191223105307.png)

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20191223105444.png)

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20191223105553.png)

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20191223111221.png)

#### 比较指令

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20191223111503.png)

注：这些指令影响N，Z，C和V标志位。

CMP: Compare

CMN: Compare negative

TST: Test

TEQ Test equivalence

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20191223111613.png)

若相等，Z=1；否则，Z=0。若产生借位，C=0；否则C=1。



![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20191223111645.png)

若产生进位，C=1；否则C=0。
对于加法和减法指令，当发生带符号溢出时，V置1；对于其它非加法和减法指令，V通常不变。

CMN指令与ADDS指令的区别在于CMN指令不保存运算结果。CMN指令可用于负数比较，比如CMN  R0,#1指令则表示R0与-1比较，若R0为-1(即1的补码)，则Z置位；否则Z复位。 



![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20191223112214.png)

TST指令与ANDS指令的区别在于TST指令不保存运算结果。TST指令通常与EQ、NE条件码配合使用，当所有测试位均为0时，EQ有效（Z=1），而只要有一个测试位不为0，则NE有效（Z=0） 。 



![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20191223112242.png)

TEQ指令与EORS指令的区别在于TEQ指令不保存运算结果。使用TEQ进行相等测试时，常与EQ、NE条件码配合使用。当两个数据相等时，EQ有效；否则NE有效。 



### 乘法指令

ARM7TDMI具有三种乘法指令，分别为：
32×32位乘法指令；
32× 32位乘加指令；
32× 32位结果为64位的乘/乘加指令。

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20191223112434.png)

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20191223112449.png)



### ARM分支指令

在ARM中有两种方式可以实现程序的跳转，一种是使用分支指令直接跳转，另一种则是直接向PC寄存器赋值实现跳转。 分支指令有以下三种：

- 分支指令B；
- 带链接的分支指令BL；
- 带状态切换的分支指令BX。

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20191223112533.png)

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20191223112539.png)

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20191223112549.png)

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20191223112559.png)

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20191223112606.png)

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20191223112639.png)



### 杂项指令

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20191223112658.png)

SWI指令用于产生SWI异常，使得CPU模式变换到管理模式，并且将CPSR保存到管理模式的SPSR中，然后程序跳转到SWI异常入口。不影响条件码标志。
该指令主要用于用户程序调用操作系统的系统服务，操作系统在SWI异常处理程序中进行相应的系统服务。

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20191223112720.png)

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20191223112733.png)



### 伪指令

ARM伪指令不属于ARM指令集中的指令，是为了编程方便而定义的。伪指令可以像其它ARM指令一样使用，但在编译时这些指令将被等效的一条或多条ARM指令所代替。ARM伪指令有四条，分别为ADR伪指令、ADRL伪指令、LDR伪指令、NOP伪指令。 

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20191223113041.png)







### 堆栈操作指令

ARM7支持四种堆栈模式：满递减(FD)、满递增(FA)、空递减(ED)、空递增(EA)

FD：堆栈地址从上往下递减，且指针指向最后一个入栈元素。
FA：堆栈地址从下往上递增，且指针指向最后一个入栈元素。
ED：堆栈地址从上往下递减，且指针指向下一个可用空位。
EA：堆栈地址从下网上递增，且指针指向下一个可用空位。

**批量数据加载/存储指令**

ARM微处理器所支持的批量数据加载/存储指令可以一次在一片连续的存储器单元和多个寄存器之间传送数据，批量加载指令用于将一片连续的存储器中的数据传送到多个寄存器，批量数据存储指令则完成相反的操作。常用的加载存储指令如下：

- LDM 批量数据加载指令 Load Multi

- STM 批量数据存储指令 Store Multi

Sample：

```assembly
STMFD R13!，{R0，R4-R12，LR} ;将寄存器列表中的寄存器（R0，R4到R12，LR）存入堆栈。

LDMFD R13!，{R0，R4-R12，PC} ;将堆栈内容恢复到寄存器（R0，R4到R12，LR）。
```



## ARM工作模式

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20191222160437.png)

特权模式：除用户模式外，其他模式都属于特权模式。

- ARM内部寄存器和一些片内外设，在硬件设计上只允许（或可选为只允许）特权模式下访问。

- 特权模式可以自由切换到其他模式。

- 用户模式不能直接切换到别的模式。

异常模式：除了用户模式与系统模式外，其他模式都属于异常模式。

- 异常模式可通过程序切换进入，也可以由特定的异常进入。
- 每种异常模式都有一些独立的寄存器，以避免异常退出时用户模式的状态不可靠。

用户和系统模式：

- 这两种模式都不能由异常进入；
- 这两种模式使用完全相同的寄存器组；

**工作模式切换图**

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20191222161251.png)



## ARM内部寄存器

37个寄存器，都是32位长度。

- 30个通用寄存器
- 1个固定用作PC（Program control rigister）
- 1个固定用作CPSR（程序状态寄存器，用来记录当前CPU的状态）
- 5个固定用作5种异常模式的SPSR（Saved Program Status Register）程序状态保存寄存器，用来保存CPSR的，返回时将SPSR赋给CPSR。

按功能分为：

- 通用寄存器：R0~R12
- 堆栈寄存器：R13，即SP
- 链接寄存器：R14，即LR，存储返回地址
- 程序计数器：R15，即PC
- 程序状态寄存器：CPSR/SPSR

每种模式下最多只能看到18个寄存器，其他寄存器虽然名字相同但是在当前模式不可见。

- 对R13这个名字来说，在ARM中共有6个名叫R13（SP）的寄存器，但是在每种特定处理器模式下，只有一个R13是当前可见的，其他的R13必须切换到他的对应模式下才能看到。这种设计叫 **影子寄存器（banked register）**



带颜色的表示每种模式下特有的寄存器。

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20191222165609.png)

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20191222165707.png)



### R13 堆栈指针(SP)

满递增

空递增

满递减

空递减

### R14 链接寄存器(LR)

R14有两个特殊功能：

- 子程序调用时 保存程序返回地址
- 当发生异常时，将R14对应的异常模式版本设置为异常返回地址（有些异常有一个小的固定偏移量）

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20191222173701.png)

#### 1. 子程序调用返回

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20191222173941.png)



BL Lable  程序带链接的跳转到标号Label处执行

- 跳转前，会在R14即LR种保存PC的当前内容，因此 可以通过LR的内容重新加载到PC种，来返回到跳转指令之后的那个指令处执行。
- 子程序返回通过`MOV PC, LR`，将父程序下一行代码的地址载入PC继续执行。
- 该指令是实现子程序条用的一个基本但常用的手段。

除了BL，还有B，它是最简单的跳转指令，会立即跳转到给定的目标地址，从那里继续执行。

注意存储在跳转指令中的实际值是相对当前PC值得一个偏移量，而不是一个绝对地址，它的值由汇编器来计算。

#### 2. 异常处理

R14_irq  保存中断时的程序地址

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20191222174947.png)

**中断嵌套问题**

R14_irq只有一个，无法嵌套处理

解决办法，用堆栈处理：

- 确保R14的对应版本在发生中断嵌套时不再保存任何有意义的值（将R14入栈），或者切换到其它处理器模式下。

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20191222175139.png)

### R15 程序计数器(PC)

可以认为它是一个通用寄存器，但对于它的使用由许多与指令相关的限制或特殊情况。

#### 读R15的限制

LDR R0,PC 读取当前PC的内容到R0

这里取得内容不是该指令的地址，根据流水线层级决定。

ARM7是三级流水，取指、译码、执行。

同一时间，一个CPU同时取指、译码、执行。

所以R15读取到的值是处理器正在取指的地址。

想要取得当前指令的地址，应该是读取的PC-8。

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20191012205451.png)

#### 写R15的限制

正常操作时，写入R15的值被当作一个指令地址，程序从这个地址处继续执行（相当于执行一次无条件跳转）。

如：MOV PC, LR

用于子程序调用返回。（前面说了）



### CPSR/SPSR 程序状态寄存器

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20191222180946.png)

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20191222172157.png)

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20191222172228.png)

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20191222172209.png)

在异常模式中，另外一个寄存器“程序状态保存寄存器SPSR可以被访问。

每种异常都有自己的SPSR，在进入异常时它保存CPSR的当前值，异常退出时可通过它恢复CPSR。

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20191222181310.png)



## ARM寻址方式⭐

[ARM的9种寻址方式](https://blog.csdn.net/u011449588/article/details/44945411)

寻址方式是根据指令中给出的地址码字段来实现寻找真实操作数地址的方式。

针对ARM内部寄存器或立即数进行寻址

- 寄存器寻址
- 立即寻址
- 寄存器移位寻址
- 多寄存器寻址

针对外部存储器的寻址

- 寄存器间接寻址
- 基址寻址
- 堆栈寻址
- 块拷贝寻址

### 寄存器寻址

1. `MOV R1, R2`  将R2的值存入R1
2. `SUB R0, R1, R2`  将R1的值减去R2的值，结果存入R0

### 立即寻址

1. `MOV R0, #0xFF000`  将立即数0xFF000存入R0

### 寄存器移位寻址

ARM指令集特有的寻址方式。

当第2个操作数是寄存器移位方式时，第2个寄存器操作数在于第1个操作数结合之前，选择进行移位操作。

1. `MOV R0, R2, LSL #3`  R2的值左移3位，结果放入R0
2. `ANDS R1, R1, R2, LSL R3`  R2的值左移R3位，然后和R1进行与操作，结果放入R1。

### 寄存器间接寻址

1. `LDR R1, [R2]`  将R2指向的存储单元的数据存入R1
2. `SWP R1, R1, [R2]`  将R1与R2指向的存储单元的数据交换，结果存入R1

### 基址寻址

将基址寄存器的值与偏移量相加，形成操作数的有效地址，基址寻址用于访问机制附近的存储单元，常用于查表、数组操作、功能寄存器访问等。

将R3中的数值加0x0F作为地址，取此地址的值保存在R2中

```assembly
LDR R2, [R3, #0x0F]
```

将R0中的数值减2作为地址，把R1的值保存到此地址中

```assembly
STR R1, [R0, #-2]
```



### 多寄存器寻址

多寄存器寻址 一次可传送几个寄存器值，允许一条指令传送16个寄存器的任何子集或所有寄存器。



将R1指向的单元中的数据读出到R2~R7、R12中，然后R1自动加4

LD表示Load，装载/读取；

M表示Multi，多寄存器；

IA表示每次传送后地址加4。

此外还有：

- LDMIB，区别是每次传送前地址加4。
- LDMDB，每次传送前地址减4。
- LDMDA指令，每次传送后地址减4。
- [LDMIA、LDMIB、LDMDB、LDMDA、STMIA、LDMFD、LDMFA、LDMED、LDMEA等指令详解](https://blog.csdn.net/u011449588/article/details/44945411)

```assembly
LDMIA R1!, {R2-R7, R12}
```

将寄存器R2~R7、R12的值保存到R0指向的存储空间，R0自动加4。

```assembly
STMIA R0!, {R2-R7, R12}
```

### 堆栈寻址

堆栈是一个按特定顺序进行存取的存储区，操作顺序为后进先出。

堆栈寻址是隐含的，它使用一个专门的寄存器（堆栈指针SP）指向一块存储区域（堆栈）。

指针所指向的存储单元即是堆栈的栈顶。

存储器堆栈可分为两种：

- 向上生长：向高地址方向生长，称为递增堆栈
- 向下生成：向低地址方向生长，称为递减堆栈

堆栈SP指向有两种方式：

- 满堆栈：SP指向最后压入的堆栈的有效数据项。

- 空堆栈：SP指向下一个待压入数据的空位置。

综上，可组合四种类型的堆栈方式：

- 满递增：指令如LDMFA、STMFA等
- 空递增：指令如LDMEA、STMEA等
- 满递减：指令如LDMFD、STMFD等
- 空递减：指令如LDMED、STMED等

记忆方式：Fill满Empty空，Add递增Decrease递减

### 块拷贝寻址

多寄存器传送指令用于将一块数据从存储器的某一位置拷贝到另一位置。（在多寄存器寻址中介绍过）

将R1~R7的数据保存到存储器中，存储器R0在保存第一个值之后增加4，增长方向为向上增长。

```assembly
STMIA R0!, {R1-R7}
```

将R1~R7的数据保存到存储器中，存储指针R0在保存第一个值之前增加4，增长方向为向上增长。

```assembly
STMIB R0!, {R1-R7}
```

### 相对寻址

相对寻址是基址寻址的一种变通。由程序计数器PC提供基准地址，指令中的地址码字段作为偏移量，两者相加后得到的地址就是操作数的有效地址。

```assembly
MOV R6, #1
```



## ARM程序设计

### ARM编程中高级语言与汇编语言对比

ARM编程中高级语言与汇编语言的对比：
（1）高级编程语言隐藏了CPU执行指令的许多细节，因此在只关心系统所具有功能的系统中，采用高级语言编写程序更为合适。
（2）CPU执行指令的细节差异会反映在系统的非功能特性上，如系统程序的规模和运行速度。因此，了解汇编语言程序设计对于嵌入式系统的设计者来说是非常必要的。 

### ARM混合编程

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20191223135358.png)

在C/C++中嵌入汇编语言：

```c
__asm__("instruction
		...
		instruction"); //Linux gcc中支持
		
__asm{
	instruction
	...
	instruction
};	//ADS, Keil中支持
        
asm("instruction [; instruction]"); //ARM C++中使用
```

在汇编语言中调用C函数：

根据ATPCS标准，函数前4个参数通过R0－R3来传递，其它参数通过堆栈(FD)传递。

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20191223135730.png)

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20191223135741.png)



## 存储器

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20191223135906.png)

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20191223140443.png)

### RAM

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20191223140516.png)

### ROM

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20191223145310.png)

Flash存储器

- Nor Flash 随机读取，适合作为内存，存放启动代码，以及作为程序存储器用。
- Nand Flash 顺序读取，适合作为外存，存放数据或文件。如作为U盘。

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20191223145843.png)

### 虚拟存储

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20191223145912.png)



## IO控制方式

I/O控制方式是指**CPU与它所管理的各接口之间**如何进行**数据传输**的控制。

**接口**是负责CPU与外围设备之间**数据交换的部件**。与CPU之间通过总线连接，与外设之间是专用连接。

### IO控制方式的种类

1. 无条件传送

2. 程序查询方式

   程序简单，占用CPU太多时间

3. 中断方式

   程序稍复杂，占用CPU时间少

4. DMA方式

   数据高速传输、数据原样传输

   <img src="https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20191030213923.png" style="zoom:50%;" />

5. I/O处理机控制方式

   同DMA方式，处理能力更强。

   数据高速传输、传输过程可以对数据进行加工处理。

   <img src="https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20191030215237.png" style="zoom:50%;" />

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20191223150241.png)



## ARM芯片-LPC21xx

该系列芯片除了采用ARM7的内核之外，还有丰富的片上资源：

1. 片上程序存储器Flash（16-512k）
2. 片上ram存储器（8-32k）
3. 可配置优先级的中断控制器（多达32个）
4. uart串口控制器
5. 拥有2个定时器
6. A/D、D/A转换器
7. 低功耗等多种模式
8. 贴片封装64引脚，芯片面积很小
9. 可以通过JTAG下载，ISP/IAP下载，不用编程器。

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20191223155908.png)

<img src="https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20191030220634.png" style="zoom:50%;" />

## GPIO接口

<img src="https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20191030220838.png" style="zoom:50%;" />

IO0DIR 寄存器中的方向控制位只有在管脚选择 GPIO 功能时才有效。对于其它功能，方向是自动控制的。 

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20191223160757.png)



## A/D接口

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20191223160932.png)

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20191223161359.png)

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20191223161457.png)

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20191223183622.png)

AD转换过程包括：

- 选择通道等参数；
- 启动转换；
- 等待转换结束；
- 读取转换结果

## UART接口

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20191223185027.png)



## 软硬件开发过程

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20191223185213.png)

需求分析是针对设计要求进行分析，以确定确定要实现哪种功能、实现到什么程度、技术指标等。

需求可分为功能部分和非功能部分。非功能性需求包括了性能、价格、物理尺寸和重量、功耗等方面的因素。

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20191223185620.png)

## 嵌入式操作系统

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20191223185517.png)

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20191223185551.png)

## 外围电路设计

- 芯片选型原则 
- 电源模块设计 
- 时钟模块设计 
- 复位电路设计 

### 芯片选型原则 

- ARM微处理器内核的选择
- 系统的工作频率 
- 芯片内存储器的容量 
- 片内外围电路的选择 

### 电源模块设计

S3C2410X的电源引脚主要有：

- VDDalive引脚给处理器复位模块和端口寄存器提供1.8V电压；
- VDDi和VDDiarm为处理器内核提供1.8V电压；
- VDDi_MPLL为MPLL提供1.8V模拟电源和数字电源；
- VDDi_UPLL为UPLL提供1.8V模拟电源和数字电源；
- VDDOP和VDDMOP分别为处理器端口和处理器存储器端口提供3.3V电压；
- VDDA_ADC为处理器内的ADC系统提供3.3V电压；
- VDDRTC为时钟电路提供1.8V电压，该电压在系统掉电后仍需维持。

### 时钟模块设计

- 时钟管理模块为各个外围模块提供时钟，在不使用某个单元时关闭其时钟以降低功耗。
- 主时钟来源可以使用外部的晶振或外部时钟。
- 时钟发生器有一个振荡器（振荡放大）连接到外部的晶体上。
- ARM微处理器内核中有一个可控频率的时钟源PLL把低频振荡器的输出作为自己的输入，产生所需的高频信号。
- 时钟发生模块有一个逻辑电路，用来在复位后或各种模式下产生稳定的时钟频率。其他的时钟均来自核内部的PLL。

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20191223190056.png)

### 复位电路设计

- 硬件复位（RESET 引脚）
- Watchdog软件复位

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20191223190843.png)

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20191223190854.png)

