# 软件工程学习笔记

## 软件生命周期

**周期图**⭐

<img src="https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20191108201606.png" style="zoom:50%;" />

<img src="https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20191108201606.png" style="zoom:50%;" />

### 软件定义时期

#### 可行性研究⭐

Feasibility Study

[图书管理系统 可行性分析报告](https://wenku.baidu.com/view/e3464417f18583d04964597d.html)

[可行性研究报告模板（国家ISO标准）](https://wenku.baidu.com/view/56077f31f111f18583d05ac1.html)

**任务**：

了解用户要求和现实环境，从**技术technique、经济economic、市场market**等方面研究并论证开发该软件系统的可行性

**技术途径**：

- 调查和了解用户要求 和 现实环境 
- 攒写调查报告
- 可行性论证 和 分析（技术、经济等）制定初步项目开发计划(人员,进 度) 

**阶段产品**：

- 可行性论证报告
- 初步的项目开发计划 

**格式**

1. 引言

   1. 编写目的
   2. 项目背景
   3. 定义
   4. 参考文献

2. 项目概述

   1. 要求
      1. 功能
      2. 性能
      3. 系统的输出
      4. 系统的输入
      5. 处理流程和数据流程
      6. 可靠性和安全性需求
      7. 完成期限
   2. 项目基本目标
   3. 条件、假定和限制
      1. 所建议系统的运行寿命的最小值
      2. 进行系统方案选择比较的时间
      3. 经费、投资的来源和限制
      4. 硬件、软件、运行环境和开发环境方面的条件和限制
      5. 可利用的信息和资源
      6. 系统投入使用的最晚时间
   4. 进行可行性分析的方法
   5. 评价尺度

3. 对现有系统的分析

   1. 处理流程和数据流程
   2. 工作负荷
   3. 费用支出
   4. 人员
   5. 设备
   6. 局限性

4. 所建议的系统

   1. 对所建议的系统的说明

   2. 处理流程和数据流程

   3. 改进之处

   4. 影响

      1. 对设备的影响
      2. 对软件的影响
      3. 对用户单位机构的影响
      4. 对系统运行过程的影响
      5. 对开发的影响
      6. 对地点和设施的影响
      7. 对经费开支的影响

   5. 可行性分析

      1. 技术条件可行性分析
      2. 经济可行性分析
         1. 支出
         2. 收益
         3. 投资回报周期

   6. 社会因素方面的可行性

      1. 法律方面的可行性
      2. 操作方面的可行性

   7. 可行性的结论

      经上述可行性分析，系统的研制和开发可以立即进行。

#### 需求分析⭐

**任务**：确定用户对待开发软件系统的需求包括：功能、性能、运行环境 约束

- 业务需求 Business Requirement ，表示组织或客户高层次的目标。
- 用户需求 User Requirement , 表示用户的目标，或用户要求系统必须完成的任务。
- 功能需求 Functional Requirement ， 规定开发人员必须在产品中实现的软件功能。有时也被称作行为需求(Behavioral Requirement)。
- 非功能需求 
  - 系统需求 System Requirement，用于描述包含多个子系统的产品（即系统）的顶级需求。
  - 业务规则，限制谁能够执行某些特定用例，或者规定系统为符合相关规定必须实现某些特定功能。
  - 质量属性(Quality Attribute)对产品的功能描述作了补充，从不同方面描述产品的各种特性。
  - 约束（Contraint）限制开发人员设计和构件系统时的选择范围。

**意义**：软件开发依据，软件验收的标准

**困难性**：难以说清,  动态变化,  歧义，复杂 

**技术途径**：

- 需求分析人员需与用户不断、反复地交流和商讨，使用户需 求逐步准确化、一致化、完全化 
- 通过 抽象、问题分解、快速原型、多视点等技术

**阶段产品**：

- **软件需求规格说明书SRS**⭐（功能，性能和运行环境约束）



### 软件开发时期

任务：是解决“如何做”的问题，即具体设计和实现在前一个时期定义的软件

阶段：概要设计、详细设计、编码和测试。

#### 概要设计阶段

**任务**：根据SRS建立目标软件系统总体结构、设计全局数据库和数据结构，规定设 计约束，制定集成测试计划等等 

**技术途径**：

- 根据SRS，自顶向下, 逐步求精,  抽象, 模块化, 局部化，信息 隐藏。

**产物**： 

- 概要设计规格说明书
- 数据库或数据结构设计说明书
- 集成测试计划 

#### 详细设计阶段

**任务**：细化概要设计所生成的各个模块, 并详细描述程序模块的内部细节(算 法，数据结构等)，形成可编程的程序模块，制订单元测试计划 

**技术途径**：根据SRS和概要设计结果进行，单入口单出口，PDL。

> 单入口单出口指为了保证开发程序的质量,要求过程中的数据流控制是必须在固定的程序段入口进入,固定的出口返回，不允许在编程中随意使用数据。

> PDL（Procedure Design Language）是类程序设计语言，也称**伪码**，是一种用正文形式表示数据结构和处理过程的设计工具。
>
> - PDL描述处理过程“怎么做”的细节
>
> - PDL的外层语法应符合一般程序设计语言常用的语法规则
>
> - PDL也称为盒图

**阶段产品**：

- 详细设计规格说明书
- 单元测试计划 

### 编码实现阶段

**任务**：根据详细设计规格说明书编写源程序，并对程序进行调试和单元 测试，验证程序与详细设计文档 一致性 

**技术途径**：以详细设计规格说明书为依据、基于某种程序设计语言进行编码。

**阶段产品**：源代码

### 集成测试阶段

**任务**：根据概要设计规格说明书，将经过单元测试的模块逐步进行集成和测试。

**技术途径**：以概要设计规格说明书和集成测试计划为依据，进行集成模块并进行测试

**阶段产品**：生成满足概要设计要求、可运行的系统源程序和系统集成测试报告 

### 软件维护时期

任务：使软件持久地满足用户的需要。

通常有4类维护活动：

- 改正性维护，也就是诊断和改正在使用过程中发现的软件错误；
- 适应性维护，即修改软件以适应环境的变化；

- 完善性维护，即根据用户的要求改进或扩充软件，使它更完善；
- 预防性维护，即修改软件为将来的维护活动预先做准备。 



## 软件生存期模型

定义：软件生存期模型是跨越整个生存期的系统开发、运作和维 护所实施的全部过程，活动和任务的结构框架 

作用：为软件开发提供原则和方法

### 瀑布模型⭐

Waterfall Model

**使用前提**：

软件需求可完全确定

Software Requirements can be completely determined.

**特点**：

- 上一阶段的变换结果是下一阶段的变换的输入，相邻两个阶段具有因果关系，紧密相联；
- 强调文档的作用；

**优点**：有利于大型软件开发过程中人员的组织organization、管理management，有利于软件开发方法methods和工具tools的研究，从而提高了大型软件项目开发的质量和效率efficiency。

**缺点**：

- 缺乏灵活性lack of flexibility，开发过程一般不能逆转，否则代价太大；
- 实际项目开发很难严格执行；actual development is difficult to strictly enforce.
- 客户往往很难给出具体的、全部的需求 specific needs；
- 到最后阶段才能得到可运行的软件版本runnable software version at final phase，要求客户有耐心。

**使用范围**：

- 客户需求非常明确clear且全面comprehensive，且在开发过程中没有或很少变化little change even none；
- 开发人员对软件的应用领域很熟悉 developer should be familiar with the application field of software；
- 用户的使用环境非常稳定；use environment is very stable.
- 开发工作对用户参与的要求很低。user involvement is not required during the development phase.

**模型**：

<img src="https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20191108204401.png" style="zoom:50%;" />

### 快速原型模型⭐

Rapid Prototype Model

**优点**：

- 有助于获取用户需求，加强对需求的理解 Help to get user requirements, reinforce to understand of requirements.
- 尽早发现软件中的错误 find errors in the software as soon as possible.
- 支持需求的动态变化 support dynamic changes in requirements. 
- 适合于需求动态变化，事先难以确定系统 

**缺点**：不能支持风险分析。 can't support risk analysis.

**模型**：

<img src="https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20191108205228.png" style="zoom:50%;" />

**原理**：经过简单快速分析，快速实现一个原型 quickly create a prototype software，用户与开发者在试用原型过程中加强通信与反馈reinforce communicate and feedback，通过反复评价repeated evaluation和改进原型improved prototype，减少误解reduce misunderstanding，弥补漏洞make up for the loophole，适应变化adapt to change，最终提高软件质量。ultimately imporve software quality

**类型**：

- 探索型原型 exploratory
  - 用于需求分析阶段；
  - 目的是弄清用户需求，探索方案的可行性；
  - 针对开发目标模糊ambiguity，用户和开发都对项目缺乏经验lack experience的情况。
- 实验型原型 experimental
  - 用于设计阶段；
  - 考核实现方案是否合适，能否实现；
- 演化型原型 evolved
  - 用于及早向用户提交一个原型系统；
  - 在得到用户认可后，将原型系统不断演变为最终的软件系统。

**运用方式**：

- 抛弃策略 anbandon strategy
  - 将原型用于开发过程的某一阶段，促使该阶段的开发结果更加完整、准确、一致、可靠，该阶段结束后，圆形随之作废。探索型与实验型就是采取此种策略。
- 附加策略 addition strategy
  - 将原型用于开发的全过程，原型由最基本的核心开始，逐步增加新的功能和需求，反复修改直到用户满意。演化型就是采取此种策略。

### 增量模型⭐

Incremental Model

增量模型是把待开发的软件系统模块化，将每个模块作为一个**增量组件**，从而分批次地分析、设计、编码和测试这些增量组件。运用增量模型的软件开发过程是递增式的过程。相对于瀑布模型而言，采用增量模型进行开发，开发人员不需要一次性地把整个软件产品提交给用户，而是可以分批次进行提交。

**优点**：

- 能在较短时间向用户提交一些有用的产品；
- 逐步增加产品功能能使用户有充裕的时间学习和适应；
- 项目失败的风险较低；
- 优先级最高的服务最先交付，再将其他增量构件逐次集成过来，因此最重要的服务将接受最多的测试。

**模型**：

整个项目采用增量模型开发，项目中的每个构件采用瀑布模型开发。

<img src="https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20191108223813.png" style="zoom:50%;" />

**增量开发需注意问题**：

- 良好的可扩展性架构设计，是增量开发成功的基础。
- 由于一些模块必须在另一个模块之前完成，所以必须定义良好的接口。
- 与完整的系统相比，增量方式正式的回顾和评审更难于实现，所以必须定义可行的过程。
- 要避免把难题往后推，首先完成的应该是高风险和重要的部分。
- 客户必须认识到总体成本不会更低。
- 分析阶段采用总体目标而不是完整的需求定义，可能不适应管理。
- 需要更加良好的计划和设计，管理必须注意动态分配工作，技术人员必须注意相关因素的变化。

### 螺旋模型

 Spiral Model

**思想**：螺旋模型是瀑布模型、原型模型的有机结合，同时增加了风险分析。

**模型**：

<img src="https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20191108224404.png" style="zoom:50%;" />

**优点**：

- 有助于获取用户需求，加强对需求的理解
- 尽早发现软件中的错误
- 支持需求的动态变化
- 支持**风险分析**
- 可降低或者消除软件开发风险
- 适合于需求动态变化，事先难以确定并且开发风险较大的系统 

### 喷泉模型

**思想**：喷泉模型（fountain model）是一种以用户需求为动力，以对象为驱动的模型，主要用于描述**面向对象**的软件开发过程。该模型认为软件开发过程自下而上周期的各阶段是相互**迭代**和**无间隙**的特性。

**优点**：

- 各阶段没有明显界限，可同步开发，提高软件项目开发效率，节省开发时间

**缺点**：

- 开发阶段的重叠意味着需要更多的开发人员参与，不利于项目管理；
- 要求严格管理文档，审核难度大。

**模型**：

<img src="https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20191108224603.png" style="zoom:50%;" />

### 统一过程模型

RUP  Rational Unified Process 

统一过程就是在软件生命周期过程中以用例为驱动、构架为中心来进行一次一次的增量式的迭代，每次迭代都是以上一次迭代为基础并生成包括构件的源代码体、需求说明、测试用例等的制品。每次的迭代又具体分为四个阶段：初始、细化、提交和转移，而在每个阶段又分为多个工作流：需求、分析、设计、实现和测试等。统一过程模型是基于面向对象方法和UML统一建模语言的。

用这种方法论来指导软件开发主要可以解决两个问题：

- 软件复用问题
- 需求变化问题

**特点**：

- 用例驱动
- 以构架为中心
- 迭代和增量的软件过程框架。

**迭代四个阶段**：

- 初始阶段
  - 主要关注项目计划和风险评估，其目的是确定是否值得开发目标系统 
- 细化阶段
  - 关心定义系统的总体框架，其目标是：细化初始需求（用况）、细化体系结构、监控风险并细化它们的优先级、细化业务案例以及制订项目管理计划 
- 构造阶段
  -  建立系统，构造信息系统的第1个具有操作质量的版本，以能够交付给客户进行测试的版本结束，有时称为测试版本 
- 移交阶段
  - 测试时期，以发布完整的系统而终止，其目标是确保信息系统真正满足客户的需求。 

### 敏捷开发

Agile Software Development

[软件开发模式之敏捷开发](https://blog.csdn.net/xiajun2356033/article/details/81513957)

- Scrum敏捷开发
- XP敏捷开发

**定义**

敏捷开发以用户的需求进化为核心，采用迭代、循序渐进的方法进行软件开发。

> 在敏捷开发中，软件项目在构建初期被切分成多个子项目，各个子项目的成果都经过测试，具备可视、可集成和可运行使用的特征。换言之，就是把一个大项目分为多个相互联系，但也可独立运行的小项目，并分别完成，在此过程中软件一直处于可使用状态。

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com//markdown20191123181448.png)

**优点**

- 敏捷开发的高适应性high adaptability，以人为本的特性。
- 更加的灵活flexibility并且充分利用了每个开发者的优势advantage，调用了每个人的工作热情passion for work。

**缺点**

- 由于其项目周期很长long project cycle，所以很难保证开发的人员不更换，而没有文档就会造成在交接handover的过程中出现很大的困难。

**Scrum开发流程三大角色**

- 产品负责人 Product Owner

  主要负责确定产品的功能和达到要求的标准，指定软件的发布日期和交付的内容，同时有权力接受或拒绝开发团队的工作成果。

- 流程管理员 Scrum Master

  主要负责整个Scrum流程在项目中的顺利实施和进行，以及清除挡在客户和开发工作之间的沟通障碍，使得客户可以直接驱动开发。

- 开发团队 Scrum Team

  主要负责软件产品在Scrum规定流程下进行开发工作，人数控制在5~10人左右，每个成员可能负责不同的技术方面，但要求每成员必须要有很强的自我管理能力，同时具有一定的表达能力；成员可以采用任何工作方式，只要能达到Sprint的目标。



## 软件工程知识体系

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com//markdown20191115162832.png)

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com//markdown20191115162929.png)





## 软件工程方法学

### 概述

软件工程：**技术**与**管理**紧密结合的工程学科。

方法学(methedology)：软件开发全过程中使用的一整套技术方法的集合，也称为范型(paradigm)，目前广泛使用的方法有：

- 传统方法（结构化方法）
- 面向对象方法

### 三要素⭐

- **方法(Method)**：开发方法，如何做
- **工具(Tool)**：支持方法的工具，提供自动/半自动软件支撑环境
- **过程(Process)**：管理过程，一系列任务框架，规定工作步骤

### 结构化方法

定义：将软件生命周期全过程依次划分为若干阶段，采用结构化技术来完成每个阶段的任务。

要点：

- 自顶向下阶段完成任务
- 要么面向行为，要么面向数据，缺乏结合。

### 面向对象方法

定义：将数据和对数据的操作结合。

要点：

- 保证各项开发活动之间的平滑过渡
- 处理大型、复杂及交互性比较强的系统更有优势

Coad和Yourdon给出的定义：

面向对象 = 对象+类+继承+消息通信

### 对象分类

- 物理对象（Physical Objects）
- 角色（Roles）
- 事件(Events)
- 交互（Interactions） 实体关联的一个对象
- 规格说明

## 类与封装

### 类

将现实生活中的对象经过**抽象**，映射为程序中的对象，对象在程序中是通过一种抽象数据类型来描述的，这种抽象数据类型称为类（Class）。

### 封装

一种信息隐蔽技术，利用抽象数据类型将数据和基于数据的操作封装在一起，对用户屏蔽对象的内部细节，对外提供接口交互。

### 继承

一种联结类的层次模型，为类的重用提供方便，提供了明确表述不同类之间共性的方法。

一般将公共类称为：

- 超类（super class）
- 父类（father class）
- 祖先（ancestor）
- 基类（base class）

而从其继承的类称为：

- 子类（subclasses）
- 后代（deslendane）
- 导出类（derived class）

### 多态

根据为请求提供服务的对象不同可以得到不同的行为，这种现象称为多态。

通过在子类中覆盖父类的方法实现多态。

绑定方式有：

- 动态绑定/后期绑定/运行时绑定
- 静态绑定/前期绑定/编译时绑定

### 消息通信

消息是一个对象与另一个对象的通信单元，是要求某个对象执行类中定义的某个操作的规格说明。

## 面向对象软件开发方法

- Rumbaugh方法  对象模型化技术（OMT)
- Coad和Yourdon方法
- Booch方法
- Jacobson方法

好处:

- 降低软件产品复杂性
- 促进软件重用

### 统一建模语言UML

UML（Unified Modeling Language）

UML吸收了很多面向对象方法的优点。

#### 特点

- 统一标准
- 面向对象
- 可视化，表达能力强
- 独立于过程
- 易掌握
- 可支持自动化代码生成工具



## 需求获取

### 什么是需求？

- 待开发软件系统的功能、性能、设计约束和其他要求。
- 主观需求，用户解决一个问题或达到一个目标所需要的一种状况或能力。
- 客观需求，系统为满足一种约定、标准、规格说明而必须满足或拥有的一种状况或能力。
- 需求文档，以上两种状态或能力的文档化表示。

### 需求分类

- 功能性需求
- 非功能性需求
  - 对系统功能或服务附加的质量约束，例如响应时间、容错性、安全性，是客户所关系的外部质量。
  - 从系统开发和维护角度出发的质量属性，例如可理解性、可扩展性、可配置性等，是开发者/维护者所关心的内部质量。

### 需求获取的任务

通过对应用问题及其环境的理解和分析，准确、一致和完全地刻画用户需求，形成**软件需求规格说明书（SRS）**。

### 需求获取的原则

- 深入浅出的原则
- 以流程为主线的原则

### 需求获取的过程

1. 开发高层的业务模型
2. 定义项目范围和高层需求
3. 识别用户类和用户代表
4. 获取具体的需求
   1. 与用户交流
   2. 现有产品或竞争产品的描述文档
   3. 系统需求规格说明
   4. 当前系统的问题报告和改进要求
   5. 市场调查和用户问卷调查
   6. 观察用户如何工作
5. 确定目标系统的业务工作流
6. 需求整理和总结
   1. 功能需求
   2. 性能需求
   3. 环境需求
   4. 可靠性需求
   5. 安全保密要求
   6. 用户界面需求
   7. 资源使用需求
   8. 软件成本消耗
   9. 开发进度需求

## 需求分析

### 需求分析的方面

- 完整性
- 正确性
- 合理性
- 可行性
- 充分性

### 需求分析的困难

- 系统目标或范围问题（片面）
- 需求不准确，模糊，不一致，歧义
- 需求易变
- 需求复杂或庞大

### 需求分析的方法

- 问题分解分析方法
  - 以层次化的方式对问题进行分解和不断细化
  - 较大规模或较为复杂的问题可被分解为若干子问题
- 多视点分析
  - 尽量全面地考虑系统中不同人的需求。
  - 最终软件系统是多方需求的综合体。

### 需求分析的结果

- 对获取的需求做部分调整，经分析去掉一部分，经分析保留一部分，经分析补充一部分。

## 需求定义

将已经过分析的需求清晰、全面、系统、准确地描述成为正式的文档。即编写 需求规格说明书（SRS：Software Requirement Specification）

## 需求验证

为确保已定义的需求规格说明准确无误，并能为客户理解和接受，需要对其进行严格的评审。



## 需求建模

在需求分析阶段所创建的模型，要着重于描述系统要做什么，而不是如何去做。不涉及软件实现细节。

常用分析方法：

- 面向数据流的结构化分析方法（SA）
- 面向数据结构的分析方法
- 面向对象的分析方法（OOA）

需求建模的作用：

- 能够表示和理解问题的信息域
- 能够定义软件将完成的功能
- 能够表示软件的行为（作为外部事件的结果）



## 功能建模 - 数据流图⭐⭐⭐

数据流图 Data Flow Diagram，DFD

[数据流图+数据字典讲解与案例](https://wenku.baidu.com/view/ca23c0edb8f67c1cfad6b8cb.html) ⭐⭐⭐

用于描述输入数据流到输出数据流的变换（加工）过程。

 由于它只反映系统必须完成的逻辑功能，所以它是一种功能模型。

> 数据流图（Data Flow Diagram）：简称DFD，它从数据传递和加工角度，以图形方式来表达系统的逻辑功能、数据在系统内部的逻辑流向和逻辑变换过程，是结构化系统分析方法的主要表达工具及用于表示软件模型的一种图示方法。 

### 常用符号

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com//markdown20191115214038.png)

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com//markdown20191115214059.png)

### 要点

- 加工数据不应与输入数据流同名
- 保持数据守恒。输出来自于输入或者产生的数据。
- 加工必须有输入输出数据流。
- 所有数据必须由一个外部实体开始，也要从一个外部实体结束。
- 外部实体之间不允许存在数据流。
-  数据流图不是传统的流程图或框图，数据流也不是控制流。数据流图是从**数据的角度**来描述一个系统 

### 分层

- 顶层图
  - 只有一张，描述系统界限，与外界环境之间的数据流，也称环境图（context diagram）
- 0层图
  - 只有一张。概述系统功能。
- 中间层图
  - 一个或多个，将加工分解细化。
- 底层图
  - 处于最底层的图，所有加工不再分解成新的子图。



### Sample-数据流图、数据字典⭐

1. 成绩管理系统

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com//markdown成绩管理系统数据流图.jpg)



## 数据建模 - E-R图⭐

实体-关系图 Entity-Relationship Diagram

### 模型元素

- 数据对象（实体）
- 描述数据对象的属性
- 数据对象间的关系

## 行为建模 - 状态图⭐

通过描述系统的状态及引起系统状态转换的事件，来表示系统的行为。也叫状态转换图。

推荐文章：[UML建模之状态图](https://blog.csdn.net/w36680130/article/details/81014032)

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com//markdown20191116201703.png)

### Sample - 存款过程

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com//markdown20191116202541.png)

### Sample - 取款过程

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com//markdown20191116202601.png)

## 数据字典⭐

数据字典（Data Dictionary，DD）由**字典条目**组成，每个条目描述DFD中的一个元素，包括：数据流、文件、数据项（组成数据流的和文件的数据）、加工、源或宿。

存储有关数据的来源、说明、与其他数据的关系、用途和格式等信息，它本身就是一个数据库，存储“关于数据项的数据”。

数据流图与数据字典密不可分，两者结合构成软件的逻辑模型（分析模型）。数据字典是分析模型的核心。

### 目的

- 提高开发效率
- 促进数据共享
- 控制数据使用

### 字典条目（词条）

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com//markdown20191116204551.png)

#### 数据流词条

- 数据流名：发票
- 说明：用于学生已付书款的依据
- 数据流来源：来自加工“审查并开发票”
- 数据流去向：流向加工“开领书单”
- 数据流组成：学号+姓名+书号+单价总价+书费合计

#### 数据元素词条

直接反应事物的某一特征。

- 类型：数字（离散值/连续值）/文字（编码类型）
- 长度
- 取值范围
- 相关的数据元素及数据结构

#### 数据存储文件词条

- 文件名：要求与DFD中名称一致
- 简述：简要说明存放什么数据
- 组成：文件的数据结构
- 输入：从哪些加工获取数据
- 输出：由哪些加工使用数据
- 存取方式：分为顺序、直接、关键码等不同存取方式
- 存取频率：单位时间的存取次数

#### 加工词条

加工可以使用判定表、判定树、结构化语言等形式表达。

- 加工名：要求与DFD中名称一致
- 编号：反应该加工的层次与父子关系
- 简述：加工逻辑及功能简述
- 输入：加工的输入数据流
- 输出：加工的输出数据流
- 加工逻辑：简述加工程序和加工顺序

#### 数据源点及数据汇点词条

- 名称：要求与DFD中名称一致
- 简述：简要描述是什么外部实体
- 有关数据流：该实体与系统交互时涉及哪些数据流
- 数目：该实体与系统交互的次数

#### 描述数据结构

- 定义式：在DFD中，数据流和数据文件都具有一定的数据结构，因此必须以一种清晰无二义性的方式来描述。
- Warnier图：用树形结构描述数据结构。

#### 定义式

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com//markdown20191116210110.png)

### Sample-发票的数据字典

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com//markdown20191116210226.png)

### Sample-存折的数据字典

定义式

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com//markdown20191116210433.png)

Warnier图

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com//markdown20191116210532.png)

### 加工规格说明

- 结构化语言
  - 语言精炼
  - 无二义性
  - 主要使用祈使句
- 判定表
  - 也叫决策表（Decision Table）
  - 条件桩（Condition Stub）：列出各种条件的对象
  - 条件条目（Condition Entry）：列出个条件对象的取值
  - 动作桩（Action Stub）：列出所有可能采取的动作
  - 动作条目（Action Entry）：列出各种条件组合下应采取的动作
- 判定树
  - 也叫决策树（Decision Tree），本质与判定表相同，表达形式不同。

#### Sample-结构化语言

审查并开发票的加工

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com//markdown20191116210954.png)

#### Sample-判定表

审批发货单的加工

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com//markdown20191116211350.png)

#### Sample-判定树

审批发货单的加工

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com//markdown20191125145329.png)



## 需求规格说明书SRS⭐⭐⭐

又称需求规约。

### 目的

- 分析需求草稿和模型，解决其二义性和不一致性，准确表达系统需求。

### 原则

- 功能与实现分离，描述"做什么"，而不是“怎么实现”
- 使用面向处理的规格说明语言
- 如果目标软件只是一个大系统中的一个元素，那么整个大系统也包括在规格说明中
- 说明系统运行的环境
- SRS是一个认识的模型，不是设计或实现的模型
- SRS必须可操作
- SRS必须容许不完备性并允许扩充
- SRS必须局部化和低耦合。

### 质量特性

- 正确性：代表用户真正需求。
- 无二义性
- 完整性：SRS应包括软件要完成的全部任务，全面考虑。
- 可验证性：需求是具体的，可测量的。不能存在不可验证的陈述。
- 一致性：不能存在矛盾、冲突。
- 可修改性：后续的修改能够较容易。多用**交叉引用**。同一需求描述若出现在不同地方，要用交叉引用。要有内容列表和索引。
- 可跟踪行：内一项需求都能与其对应的来源、设计、源代码和测试用例关联。可追溯其来源。可给每一项需求编号。

### 主要内容

- 引言
- 数据描述
  - 数据流图
  - 数据字典
- 功能描述
- 性能描述
- 特殊需求

### 需求管理

分析变更影响并控制变更的过程，主要包括 变更控制、版本控制和需求跟踪等活动。

需求管理就是管理需求变化的过程。

- 如何提交一个需求变更请求？

- 如何分析需求变更的影响？

- 如何批准或驳回需求变更?

- 如何实现需求变更？



## 软件设计的原则

### 模块化设计

- 模块分解
- 信息隐藏
- 模块独立化
  - 高内聚、低耦合



## 结构化设计 - 耦合

耦合性是程序结构中各个模块之间相互关联的度量。它取决于各个模块之间接口的复杂程度、调用模块的方式以及哪些信息通过接口。

目标是追求低耦合。

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20191021184846.png)

### 非直接耦合（Nondirect Coupling）

模块之间没有直接关系，它们之间的联系完全通过主模块的控制和调用来实现。

### 数据耦合（Data Coupling）

模块之间访问，通过简单数据参数（不是控制参数、全局变量或外部变量）来交换输入输出信息。

### 标记耦合（Stamp Coupling）

模块之间访问，通过参数表传递记录信息，而不是简单变量。

### 控制耦合（Control Coupling）

一模块通过传送开关、标志、名字等控制变量来控制选择另一模块的功能。

### 外部耦合（External Coupling）

一组模块都访问同一全局简单变量。

### 公共耦合（Common Coupling）

一组模块都访问同一公共数据环境。

### 内容耦合（Content Coupling）

一个模块直接访问另一模块的内部数据。

一个模块不通过正常入口转到另一模块内部。

两模块有部分程序代码重迭。

一个模块有多个入口。

## 结构化设计 - 内聚

模块内聚性越强，功能独立性越好，对形成的模块结构有比较好的作用。

目标是追求高内聚。

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20191021185955.png)

### 巧合内聚（Coincidental Cohesion）

多个模块有相同的代码块，将他们抽取出来形成单独模块。

### 逻辑内聚（Logical Cohesion）

这种模块把几种相关的功能组合起来，每次被调用时，由判定参数决定执行哪一种功能。

### 时间/经典内聚（Classical Cohesion）

模块各功能执行与时间有关，通常要求所有功能必须在同一时间段执行。

### 过程内聚（Procedural Cohesion）

将流程中某一部分划分成一模块，多个部分划分成多个模块。例如流程图设计时。

### 通信内聚（Communication Cohesion）

一个模块内各功能部分都使用了相同的输入数据，或产生了相同的输出数据，则称之为通信内聚模块。通常，通信内聚模块通过数据流图来定义的。

### 顺序/信息内聚（Sequential/Information Cohesion）

完成多个功能，各个功能都在同一数据结构上操作，每一项功能有一个唯一入口。

### 功能内聚（Function Cohesion）

一模块中各部分都是完成某一功能的组成部分，目标一致，协同工作，紧密联系，不可分割。



## 结构化设计 - 独立性

综上，具有高内聚低耦合的模块才是模块独立性强的模块。

### 提高抽象层次

抽象指忽视一个主题中与当前目标无关的方面，更充分地注意与当前目标有关的方面。

设计时应尽量提高软件的抽象层次。

### 复用性设计

复用指同一事物不做修改或稍加修改就可以多次重复使用。

软件的复用部分称为**软构件**。

### 灵活性设计

保证软件灵活性设计的关键是抽象。

引入灵活性的方法有：

- 降低耦合，提高内聚（提高替换能力）
- 抽象（多态的接口和基类）
- 不要将代码写死（消除不应该的常量）
- 抛出异常（由操作的调用者处理异常）
- 多写可复用的代码

## 程序复杂度⭐

软件复杂性主要表现在程序的复杂性，程序复杂性主要指模块内程序的复杂性。

常见的定量度量软件复杂性的方法有：

- 代码行度量法
- McCabe度量法/环路度量法⭐
- Halstead的软件科学

### McCabe度量法计算环形复杂度(Cyclomatic Complexity)

根据程序控制流的复杂程度定量度量程序的复杂程度，这样度量出来的结果称为程序的环形复杂度。

**计算方法**

- 流图中的区域数等于环形复杂度
- 流图G的环形复杂度V(G)=E-N+2，其中，E是流图中边的条数，N是结点数。
- 流图G的环形复杂度V(G)=P+1，其中，P是流图中判定结点的数目。

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com//markdown20191124171652.png)

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com//markdown20191124171729.png)

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com//markdown20191124171746.png)



- 环形复杂度反映程序分支数或循环个数。

- 环形复杂度高的程序往往是最困难、最容易出问题的程序。

- 实践表明：模块规模以V(G) <= 10 为宜。



### 程序图/流图

程序图是一种简化了的流程图。仅描述程序的控制流程，完全不表现对数据的具体操作以及分支或循环的具体条件。

流程图中的各种处理框都被简化为结点。

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com//markdown20191124171408.png)





## 设计过程

结构化设计是将结构化分析的结果（数据流图DFD）映射成软件的体系结构（结构图SC）。

[DFD图转换为SC图](https://blog.csdn.net/hastar521/article/details/7463785)

### 变换流

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com//markdown20191116224655.png)

### 事务流

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com//markdown20191116224825.png)

 ![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com//markdown20191117110901.png)

## Sample-图书采购子系统

### 数据流图DFD

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com//markdown20191117111039.png)

### 结构图SC

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com//markdown20191117111142.png)

## 结构图优化

- 消除重复功能，改善软件结构
- 模块的作用范围应在控制范围内
- 尽可能减少高扇出结构，随着深度增大扇出
- 避免或减少使用病态连接
  - 设计尽量达到单入口单出口
  - 用参数表传递模块间数据
- 模块大小要适中
  - 语句行数不超过500行

## Sample-银行存储系统

### 数据流图DFD

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com//markdown20191117111944.png)

### 结构图SC

#### 确定输入流和输出流的边界

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com//markdown20191117112034.png)

#### 完成第一级分解

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com//markdown20191125145403.png)

#### 完成第二级分解

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com//markdown20191117112102.png)

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com//markdown20191117112120.png)

### 结构图优化

由于调度模块下只有两种事务，可将调度模块合并到上级模块中。

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com//markdown20191117112215.png)

检查密码模块的作用范围不在其控制范围之内

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com//markdown20191117112413.png)

提高模块独立性，并对“输入事务”模块进行细化。

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com//markdown20191117112449.png)



## 人机交互接口设计

### 用户界面应具备的特性

- 可使用性
- 灵活性
- 可靠性

### 用户类型

- 外行型
- 初学型
- 熟练型
- 专家型

### 界面设计类型

- 输入设计
  - 输入描述
    - 问题描述语言POL
    - 带表头的数据表格TABLE
    - 图形输入
    - 菜单MENU
  - 输入方式
    - 批处理
    - 交互式
    - 磁性媒体
  - 编译算法设计
- 输出设计
  - 输出描述
    - 图形
    - 数据表格
    - 正文（说明文件）
  - 输出方式
    - 硬拷贝
    - 磁性媒体
  - 编译加工，算法设计
- 操作设计
- 使用手册

### 设计准则

- 一致性
- 操作步骤少
- 提供撤销功能
- 减少记忆负担
- 提高学习效率



## 数据设计

## 文件设计

适用场景

- 数据量较大的非结构化数据，如多媒体信息
- 数据量大，信息松散，如历史记录，档案文件。
- 非关系层次化数据，如系统配置文件
- 对数据的存取速度要求极高。
- 临时存放的数据。

组织方式

- 顺序文件：一种是连续文件，另一种是串联文件。
- 直接存取文件：通过记录的关键字，计算得到存放地址。
- 索引顺序文件：其基本数据记录按顺序文件组织，记录排列顺序必须按关键字升序或降序，且具有索引部分，索引部分也按同一关键字。
- 分区文件：主要用于存放程序。
- 虚拟存储文件：基于操作系统的请求页式存储管理功能而建立的索引顺序文件

### 数据库设计

分类

- 网状数据库
- 层次数据库
- 关系数据库
- 面向对象数据库
- 文档数据库
- 多维数据库

关系映射

- 一对一关系
- 一对多关系
- 多对多关系



## 详细设计阶段

### 任务

- 为软件结构图SC中的每一个模块确定采用的算法和模块内数据结构。
- 确定模块的外部接口和用户界面
- 为每一模块设计一组测试用例

### 描述工具

- 图形工具
  - 程序流程图
  - N-S图
  - PAD图
  - 决策树
- 表格工具
  - 决策表
- 语言工具
  - 伪代码
    - 类Pascal
    - 类C语言

### 原则

- 控制结构只准有一个入口和一个出口
- 程序语句组成容易识别的块
- 复杂结构应该用基本控制结构进行组合嵌套实现
- 严格控制GOTO语句
- 尽量采用自顶向下(Top-Down)、逐步细化(Stepwise Refinement)的原则

### 程序流程图

又称程序框图。

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com//markdown20191117114236.png)

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com//markdown20191117114305.png)

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com//markdown20191117114317.png)

### N-S图⭐

又称盒图。

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com//markdown20191117114420.png)

优点：

- 功能域很直观

- 容易确定局部数据和全局数据的作用域
- 容易表现嵌套关系
- 容易表示模块的层次结构

### PAD图⭐

Problem Analysis Diagram

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com//markdown20191117114738.png)

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com//markdown20191117114847.png)

优点：

- 程序层次分明
- 逻辑易读、易懂、易记
- 易转换为高级语言源程序
- 即可表示程序逻辑，也可用于描绘数据结构
- 符合自顶向下、逐步求精的原则

### 伪代码

也称程序设计语言，Program Design Language

语句结构

- 简单陈述句
- 判定结构：IF_THEN_ELSE或CASE_OF
- 循环结构：WHILE_DO或REPEAT_UNTIL

数据说明

- 定义数据的类型和作用域
- `TYPE <变量名> AS <数据类型> <作用域>`

程序块

```plsql
BEGIN <块名>
	<一组伪代码语句>
END
```

子程序结构

```plsql
PROCEDURE <子程序名> <一组属性>
	INTERFACE <参数名>
		<程序块或一组伪代码语句>
END
```

重复型结构

```plsql
DO WHILE <条件描述>
	<...>;
ENDDO
```

```plsql
REPEAT UNTIL <条件描述>
	<...>;
ENDREP
```

多路选择结构

```
CASE OF <case 变量名>
	WHEN <case 条件1> SELECT <...>;
	WHEN <case 条件1> SELECT <...>;
	...
	DEFAULT: <...>;
ENDCASE
```

输入/输出结构

```plsql
READ/WRITE TO <设备> <I/O表>
```



## 统一建模语言UML⭐⭐⭐

UML（Unified Modeling Language）

UML吸收了很多面向对象方法的优点。

### 特点

- 统一标准
- 面向对象
- 可视化，表达能力强
- 独立于过程
- 易掌握
- 可支持自动化代码生成工具

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com//markdown20191117120433.png)

### 事物

- 结构事物
- 行为事物
- 分组事物
- 注释事物

#### 结构事物

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com//markdown20191117120514.png)

- 类：具有相同属性、操作、关系、语义的对象的描述
- 主动类：具有一个或多个进程或线程，能够启动控制活动
- 接口：描述元素的外部可见行为，定义的是一组操作的描述，而不是操作的实现
- 对象：类的实例，名字下面加下划线，属性要有具体值
- 协作：描述一组事物间的相互作用的集合
- 用例：代表一个系统或系统的一部分行为，是一组动作序列的集合
- 参与者：与系统交互的人或外部系统或硬件设备
- 构件：系统中物理存在，可替换的部件
- 节点：运行时存在的物理元素

#### 行为事物

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com//markdown20191117121236.png)

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com//markdown20191117121248.png)

- 交互：实现某功能的一组构件事物之间的消息的集合，涉及消息、动作序列、链接
- 状态机：描述事物或交互在生命周期内响应事件所经历的状态序列

#### 分组事物

为了降低模型复杂度

- 包：将模型元素组织成组的机制，其他事物都可以放进包内。

#### 注释事物

模型的解释部分

- 注释：描述和标注模型元素



### 关系

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com//markdown20191117121520.png)

- 依赖：一个事物发生变化会影响另一依赖事物
- 关联：事物的对象之前的联系
- 泛化：可以看作是继承关系
- 实现：类元之间的语义关系

#### 依赖种类

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com//markdown20191117121750.png)

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com//markdown20191117121802.png)

#### 关联关系

- 普通关联
  - ![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com//markdown20191117121858.png)
  - ![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com//markdown20191117121920.png)
  - ![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com//markdown20191117121952.png)
- 限定关联
  - 把模型中的多重性从一对多变成一对一，或多对多简化成多对一
  - ![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com//markdown20191117122054.png)
- 关联类
  - 对关联关系的语义做详细的定义、存储和访问。
  - ![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com//markdown20191117122205.png)
- 聚合（Aggregation）
  - 也称聚集，描述整体和部分之间的结构关系
  - ![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com//markdown20191117122253.png)
- 导航
  - 可加箭头表示方向

#### 泛化关系

泛化（generalization）关系就是一般类和特殊类之间的继承关系。

- 普通泛化
- 受限泛化
  - 具有约束条件
    - 交叠（overlapping）
    - 不相交（disjoint）
    - 完全（complete）
    - 不完全（incomplate）

#### 实现关系

实现（implement）是泛化关系和依赖关系的结合，也是类之间的语义关系。



软件开发生命周期（SDLC）的各阶段都需要使用UML图。

- 用例图
- 类图
- 时序图
- 协作图
- 活动图
- 状态图

### 用例图⭐⭐⭐

用例图（Use Case Diagram）也称用户模型图。

从客户角度来描述系统功能。

[UML建模-用例图](https://www.cnblogs.com/lcword/p/10472040.html)

**基本组件**

- 参与者actor：与系统交互的人或事物或其他系统
- 用例use case：代表某项功能
- 关系：用例之间的关系
  - 关联Association： 表示参与者与用例之间的通信，任何一方都可发送或接受消息。 
    - ![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com//markdown20191117155158.png)
  - 泛化Inheritance：继承
    - 【箭头指向】：指向父用例
    - ![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com//markdown20191117155239.png)
  - 包含： 当某用例的事件流过于复杂时，为了简化用例的描述，我们也可以把某一段事件流抽象成为一个被包含的用例 
    - 【箭头指向】：指向分解出来的功能用例
    - ![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com//markdown20191117155317.png)
  - 扩展：扩展关系是指用例功能的延伸，相当于为基础用例提供一个附加功能。不一定执行。
    - ![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com//markdown20191117155442.png)

### Sample-用例图

自顶向下，逐步细化。

1. 存取款

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com//markdown20191117155618.png)

2. 人力资源管理

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com//markdown20191117154754.png)

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com//markdown20191117154837.png)

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com//markdown20191117154907.png)

### 类图⭐⭐⭐

描述系统的静态结构

[Java大白话讲解设计模式之 UML类图](https://www.jianshu.com/p/2828874af134)

[UML类图](https://www.jianshu.com/p/57620b762160)

[UML类图几种关系](https://jingyan.baidu.com/article/ad310e80f7d5c01848f49e6b.html)

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com//markdown20191117173257.png)

```none
-表示private  
#表示protected 
~表示default,也就是包权限  
_下划线表示static  
斜体表示抽象 
```

1. 关联 Association 【代码体现】：成员变量
   - 是一种**拥有的（长期的、平等的）**关系，它使一个类**知道另一个类的属性和方法**

2. 聚合 Aggregation 【代码体现】：成员变量
   - 是整体与部分的关系，且**部分可以离开整体而单独存在**
   - 聚合关系是关联关系的一种，是强的关联关系；关联和聚合在语法上无法区分，必须考察具体的逻辑关系。

3. 组合 Composition 【代码体现】：成员变量
   - 是整体与部分的关系，但**部分不能离开整体**而单独存在。
   - 组合关系是关联关系的一种，是比聚合关系还要强的关系，它要求普通的聚合关系中代表整体的对象**负责代表部分的对象的生命周期**。

4. 依赖 Dependency 【代码表现】：局部变量、方法的参数或者对静态方法的调用
   - 是一种**使用的**关系（**临时性的**），即**一个类的实现需要另一个类的协助**，所以要尽量不使用双向的互相依赖。

5. 泛化 Generalization

6. 实现 Realization

---

 关系强弱排序： 泛化 = 实现 >  组合>聚合>关联>依赖 	

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com//markdown20191117173304.png)





![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com//markdown20191125150921.png)



### 顺序图/时序图⭐⭐⭐

描述对象之间的动态交互关系，着重表现对象间消息传递的时间顺序。

[UML时序图](https://blog.csdn.net/fly_zxy/article/details/80911942)

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com//markdown20191117193859.png)

元素

- 角色 Actor
- 对象 Object
- 生命线 Lifeline
- 控制焦点 ACtivation
- 消息 Message
  - 同步消息 Synchronous Message
  - 异步消息 Asynchronous Message
  - 返回消息 Return Message
- 自关联消息

常用组合片段

- 抉择 Alt
- 选项 Opt
- 循环 Loop
- 并行 Par

### Sample-时序图

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com//markdown20191117194926.png)



### 协作图/合作图/通信图⭐

Collaboration，是顺序图的一种变化形式，用于描述相互写作的对象间的交互关系和链接关系。

[UML系列-协作图](https://www.jianshu.com/p/88aa96090105)

元素

- 对象
- 链接
- 消息
  - 简单消息
  - 同步消息
  - 异步消息
  - 反身消息

### Sample-协作图

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com//markdown20191117195018.png)



### 状态图⭐

见上文



### 活动图⭐

Activity Diagram

描述一次行为活动的流程，主要强调了行为活动的顺序和条件控制。

[UML-活动图](https://www.jianshu.com/p/fc28557715c3)

**元素**

- 开始 inital
- 结束 final
- 活动 action
- 控制流 control flow
- 决策 decision
- 合并 merge
- 泳道 swimlanes
  - 垂直
  - 水平
- 分岔汇合 join
- 分流 fork
- 接受信号 acceptsignal



### 构件图

组件图(Component Diagram)又称为构件图，他描述的是在软件系统中遵从并实现一组接口的物理的、可替换的软件模块。

[UML-构件图](https://blog.csdn.net/soft_zzti/article/details/80331932)

### 部署图

部署图描述的是系统运行时的结构，展示了硬件的配置及其软件如何部署到网络结构中。

一个系统模型只有一个部署图，部署图通常用来帮助理解分布式系统。

[UML-部署图](https://blog.csdn.net/weixin_42369687/article/details/90963430)

### UML小结

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com//markdown20191117194618.png)

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com//markdown20191117194633.png)

- 时序图强调交互的时间次序。

- 协作图强调交互的空间结构。

- 顺序图和协作图适于单个用例中多个对象的行为

- 状态图适于描述跨越多个用户中单个对象的行为

- 活动图适于描述并发的、较复杂的行为

**名词**

AN 需求分析 Analysis

BD Base Design 基本设计

FD Functional Design 结构设计

DD Detailed Design 详细设计

C Coding 编码

UT Unit Testing 单元测试

CT Component Testing 组件测试

TT Technical Testing 技术测试

IT Integration Testing 集成测试

ST System Testing 系统测试

UAT User Acceptance Testing 验收测试

OP Operation 发布

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com//markdown20191117201522.png)



## 设计原则⭐⭐⭐

- 里氏替换原则
  - 凡是父类可以出现的地方，子类都可以出现
- 开闭原则
  - 一个软件实体应该对扩展开放，对修改关闭
- 单一职责原则
  - 一个类应该尽量只有一个引起它发生变化的原因
- 依赖倒置原则
  - 抽象不应该依赖于具体，而是具体依赖于抽象
- 接口隔离原则
  - 应该提供小而专的接口，而不是大而全的接口
- 组合复用原则
  - 优先使用组合/聚合进行复用，而不是继承
- 迪米特原则
  - 一个软件实体应该尽可能少的与其他实体发生相互作用



## 设计模式⭐⭐⭐

**Design patterns** help you learn from others 'successes instead of your own failures'

设计模式描述了设计中不断重复遇到的问题以及该问题的解决方案的核心。

采用设计模式的设计和代码具有良好的可维护性、可复用性和可升级性。

### 优点

- 改善个人和团队学习
- 促进对改良设计的选用
- 增加对基本面向对象设计原则的理解

- 增加复用性，减少设计的多样性
- 增加设计变更的灵活性

### 23种经典设计模式

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com//markdown20191117212927.png)

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com//markdown20191117212941.png)

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com//markdown20191117212950.png)

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com//markdown20191117213000.png)

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com//markdown20191117213008.png)

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com//markdown20191117213016.png)

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com//markdown20191117213024.png)

### 设计模式分类

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com//markdown20191117213054.png)



### 策略模式⭐

Strategy Pattern

**设计原则**

- 针对接口编程，而非针对实现编程

- Has-a比is-a更好，即组合(composition)比继承(extend)好
- 多用组合，少用继承

**适用场景**

- 需要动态地在几种算法中选择一种，可将这些算法封装到一个个的具体算法类中。
- 一个对象有很多的行为。
- 不希望客户端知道复杂、与算法相关的数据结构

#### Sample-鸭子的行为

[代码实现](https://gitee.com/YanKeyon/DesignPatterns-Sample)

 ![img](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20191102205234.png) 

#### Sample-电影票打折

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com//markdown20191117213924.png)



### 观察者模式⭐

也称 发布-订阅模式

观察者模式在对象之间定义了一个一对多的依赖，如果一个对象（被观察者/发布者）改变了状态，就通知依赖于它的其他对象们（观察者/订阅者），并自动地更新这些对象。

[Head First设计模式之观察者模式](https://blog.csdn.net/gdouchufu/article/details/50062079)

**设计原则**

- 当两个对象是松耦合的，它们彼此间能交互，但相互了解很少。
- 提供了主题和观察者之间的松耦合设计

**应用场景**

- 监听器



#### Sample-气象站

[代码实现](https://gitee.com/YanKeyon/DesignPatterns-Sample)

公司中标了一个项目，要为Weather-O-Rama气象站建立下一代气象观测站！ 
要求：

- 建立一个应用，有三个布告板，分别显示目前状况、气象统计、天气预报
- 一旦气象站有新的测量数据，必须立即更新布告板
- 系统可扩展，可以随时添加或移除定制的各种布告板



### 工厂模式⭐

[工厂模式](https://blog.csdn.net/wilschan0201/article/details/73162899)



1. 简单(静态)工厂模式

   ![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com//markdown20191125183443.png)

2. 工厂方法模式

   工厂方法模式通过让工厂子类决定创建的具体对象时哪些，来达到将对象创建过程封装的目的。

   ![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com//markdown20191125183458.png)

3. 抽象工厂模式

   抽象工厂模式提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类

   ![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com//markdown20191125185758.png)



### 适配器模式⭐

[Head First 适配者模式 文章1](https://www.cnblogs.com/skyseavae/p/10486438.html)

[Head First 适配者模式 文章2](https://www.cnblogs.com/shamgod/p/5260053.html)

Adapter 适配器

Adaptee 适配者

Target 被适配的目标接口

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com//markdown20191125191527.png)

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com//markdown20191125191320.png)

### 单例模式



## 软件体系结构/架构

软件体系结构 Software Architecture 主要对大规模的复杂软件系统进行总体的结构设计和规格说明。

软件体系结构是软件工程学的自然延伸。

软件需求与软件设计之间的一座桥梁，着重解决软件系统的结构和需求向实现平坦过渡的问题。

### 体系结构的演化

1. 无体系结构：汇编语言、小规模应用程序
2. 萌芽阶段：程序结构设计、DFD
3. 初期阶段：系统结构模型、UML
4. 高级阶段：高层抽象结构、"4+1"模型

### 架构风格-管道和过滤器

过滤器：通过对输入数据流进行局部变换,并采用渐增式计算方法,在未处理完所有输入数据以前,就可以产生部分计算结果,并将其送到输出端口。
管道：提供交互，负责链接一个过滤器的输出和另一个过滤器的输入。

**过滤器分类**

- 输入过滤器
- 处理过滤器
- 输出过滤器

**优点**

- 良好的隐蔽性，高内聚低耦合
- 支持软件重用
- 系统维护简单
- 支持并行执行

**缺点**

- 经常退化为批处理系统
- 不适合处理交互的应用
- 编写过滤器复杂

**适用场景**

- 编译器：在代码编码过程中，编译器需执行词法分析阶段，句法分析阶段，语义分析阶段，代码生成阶段，每一个阶段的输出作为后一阶段的输入。
- Servlet提供的Filter：通过使用 Filter 为 Web 应用开发者能够在请求到达 Web 资源前截取请求, 进行相应处理; 同理, 也能够在请求资源反馈之前, 截取响应进行处理, 将处理后的结果反馈给客户端。

### 架构风格-数据抽象和面向对象组织

...



### 架构风格-基于事件的隐式调用

对象之间通过方法调用进行交互，但是调用是隐式的，通过事件机制进行调用触发。

对象可以广播事件，可以通过事件注册将某个方法和事件进行绑定。一旦触发该事件，所有与该事件绑定的方法都将被调用。

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com//markdown20191117204027.png)

**应用场景**

- 数据库中的一致性约束
- IDE、编辑器支持的语法检测
- 开发工具中调试过程中的变量监视器

**优点**

- 问题分解：将计算与交互分离
- 系统演化和重用：通过事件注册，新组件易引入

**缺点**

- 构件放弃了对系统计算的控制
- 大数据量的数据交互往往没法用事件携带
- 对事件触发的方法调用次序无法控制



### 架构风格-分层系统

层次系统体现出一种层次结构

- 每一层都向它的上一层提供服务
- 每一层都使用它下一层的服务

- 下层无需知道上层存在，上层无需知道下层细节

**应用场景**

- 计算机网络分层模型

**优点**

- 功能的改变只影响相邻的上下层
- 支持重用
- 支持基于抽象程度递增的系统设计

**缺点**

- 并非每个系统都可进行分层设计
- 很难找到一个合适的、正确的层次抽象方法

### 架构风格-仓库系统及知识库

- 中央数据单元构件：代表系统当前的各种状态

- 相对独立的构件集合：这些构件对中央数据库单元进行操作

**仓库系统分类**

- 传统型数据库
- 黑板系统

**应用场景**

- 信号处理与模式识别领域
- FTP服务器

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com//markdown20191117204759.png)

**优点**

- 便于多个用户共享大量数据
- 便于添加新的知识源应用程序

**缺点**

- 对黑板数据结构的修改较困难，要考虑不同知识源对共享数据结构达成一致
- 系统复杂，需要一定的同步/加锁机制保证数据结构的完整性和一致性

### 架构风格-C2风格

由连接件绑定在一起的按照一组规则运作的并行构件网络

构件与构件之间的直接连接是不允许的

**规则**

- 通讯规则：消息是构件间的唯一通讯途径
- 服务调用规则：每个构件只能感知层次高于自己的构件提供的服务，不能感知层次低于自己的构件的服务
- 请求消息只能向上层传送
- 通知消息只能向下层传送

**应用场景**

- 基于构件和消息的体系结构的应用 ActiveMQ

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com//markdown20191117205601.png)



### 架构风格-C/S风格

Client/Server 客户/服务器风格

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com//markdown20191117210509.png)

**优点**

- 模型简单
- 将大的应用处理任务分布到许多通过网络连接的低成本计算机上，以节约大量费用。

**缺点**

- 开发成本较高
- 客户端程序设计复杂
- 软件移植困难
- 软件维护和升级困难



**三层C/S结构风格**

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com//markdown20191117210852.png)

层次越多，运行效率越低。



### 架构风格-B/S风格

Browser/Server 浏览器/服务器风格

利用Web技术，结合浏览器的多种脚本语言，用通用浏览器就实现了原来需要复杂的专用软件才能实现的功能，节约了开发成本。

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com//markdown20191117211128.png)

**优点**

- 系统安装、修改和维护全在服务端，升级容易，零客户端

**缺点**

- 响应速度一般低于C/S架构



### 架构风格-C/S与B/S混合风格

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com//markdown20191117211517.png)

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com//markdown20191117211528.png)



### 架构风格-MVC风格

Model模型层

- 对系统信息进行如何处理规则的实现部分。

View视图层

- 界面

Controller控制层

- 将M与V联系起来

**应用实例**

- Struts框架



### 模式-架构-框架 小结

- 设计模式是对通用设计问题的重复解决方案
- 体系结构风格是描述某一特定应用领域中系统组织方式的惯用模式
- 框架是整个或部分系统的可重用设计



## 软件测试

### 目的

- 测试是程序的执行过程，目的在于发现错误
- 好的测试用例在于能发现至今未发现的错误

### 原则

- 充分注意测试中的群集现象
- 严格执行测试计划，排除测试的随意性
- 应当对每一个测试结果作全面的检查
- 妥善保存测试计划、测试用例、出错统计和最终分析报告，为维护提供方便

### 测试对象

- 需求分析、概要设计、详细设计、程序编码等各阶段所得到的文档资料，都应称为软件测试的对象。

- 软件测试并不等于程序测试。

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com//markdown20191118144849.png)

- 自底向上，逐步集成。

### 测试技术

- 白盒测试
- 黑盒测试

### 测试技术-白盒测试

也称玻璃盒测试，结构测试或逻辑驱动测试。

允许测试人员利用程序内部的逻辑结构及有关信息，来设计或选择测试用例，对程序所有逻辑路径进行测试。

#### 测试内容

- 对程序模块的所有独立执行路径至少测试一次
- 对所有的逻辑判定Logic Judge，取真与取假都至少测试一次
- 在循环的边界和运行边界限内执行循环体loop
- 测试内部数据结构的有效性Validity

### 测试技术-黑盒测试

测试人员完全不考虑程序内部逻辑结构和内部特性，只根据SRS，检查程序功能是否符合它的功能说明。

#### 测试内容

- Alpha/Beta Testing
- 菜单/帮助测试
- 发行测试
- 回归测试

#### 测试目的

- 是否有不正确或遗漏的功能
- 输入是否正常接收
- 能否输出正常结果
- 是否有数据结构错误或外部信息访问错误
- 性能是否满足要求
- 是否有初始化或终止性错误

### 测试技术-人工测试

- 代码审查
  - 以小组会形式，发现程序在结构、功能、编码风格等存在的问题。
- 走查
  - 以小组会形式，把测试数据输入到被测程序，并在纸上跟踪监视程序。
- 桌前检查
  - 设计模块时，程序员自己检查。

### 白盒测试用例设计⭐⭐⭐

#### 逻辑覆盖测试方法⭐⭐⭐

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com//markdown20191118145707.png)

- 语句覆盖

  步骤：

  1. 根据流程图，找出所有语句（包括条件语句与普通语句）所在路径。
  2. 图示走ace一条测试用例即可实现语句覆盖。

  ![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com//markdown20191125211406.png)

  

- 判定覆盖

  步骤：

  1. 找出所有判定，要求每个判定都执行一次true和false。
  2. 图示 设判定1与判定2
  3. 那么测试用例1可以为：判定1=true，判定2=true，走ace
  4. 测试用例2可以为：判定1=false，判定2=false，走abd

  ![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com//markdown20191125211806.png)

- 条件覆盖

  步骤：

  1. 列出所有条件的取值标记，设出取真与取假
  2. 将列出的取值标记进行组合，要求所有取值标记都出现一次。
  3. 完成步骤2 至少需要两个用例。
  4. 除了图示的取值，测试用例1也可以为：$T1T2T3T4$，测试用例2为：$\bar T1 \bar T2 \bar T3 \bar T4$

  ![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com//markdown20191125210945.png)

  

- 判定-条件覆盖

  步骤：

  1. 要求既满足判定，也满足条件。
  2. 先满足条件覆盖，步骤不再赘述。
  3. 在满足条件覆盖的测试用例中，找满足判定覆盖的测试用例。
  4. 最终找出测试用例为如图所示，不唯一。

  ![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com//markdown20191125212949.png)

- 条件组合覆盖

  步骤：

  1. 列出所有判定的所有条件的组合，要求每个组合都测试一次。
  2. 列出所有条件的取值标记，设出取真与取假。
  3. 将所有标记进行组合。

  ![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com//markdown20191125213400.png)

  ![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com//markdown20191125213832.png)

  ![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com//markdown20191125213846.png)

- 路径覆盖

  - 程序中的每一条可能的程序执行路径至少测试一次。
  - 如果程序中含有循环，则每个循环至少执行一次。
  
  步骤：
  
  1. 根据流程图，找出所有边。
  2. 找出从起点到终点所有可能路径。
  
  ![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com//markdown20191126133948.png)



### 黑盒测试用例设计⭐⭐⭐

- 等价类划分法⭐⭐⭐
- 边界值分析⭐⭐
- 错误猜测法
- 因果图法

#### 等价类划分法⭐⭐⭐

即等价分类法。

把输入数据的可能值划分为若干等价类。

在每一个等价类中取一个数据作为测试的输入条件。

[等价类划分法测试用例设计举例](https://blog.csdn.net/weixin_36158949/article/details/79368656)

**步骤**

1. 划分等价类（列出等价类表）
2. 选取测试用例

**划分等价类**

- 有效等价类
  - 对于程序规格说明来说，合理的、有意义的输入数据构成的集合。
- 无效等价类
  - 对于程序规格说明来说，不合理的、无意义的输入数据构成的集合。

**强调选取值的值域。**

#### 边界值分析⭐⭐

如果输入数据规定了值的个数，则用最大个数、最小个数，比最大个数多1，比最小个数少1的数作为测试数据。

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com//markdown20191118152057.png)

**强调边界性的值。**

#### 错误猜测法

猜测被测程序哪些地方容易出错，然后针对可能的薄弱环节设计测试用例。

#### 因果图法

借助图形来设计测试用例。

适用于被测程序具有多种输入条件，程序的输出又依赖于输入条件的个各种组合的情况。

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com//markdown20191118152327.png)

### 软件测试策略

- 单元测试
- 组装测试
- 确认测试
- 系统测试

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com//markdown20191118152359.png)

#### 单元测试⭐

又称模块测试，针对程序模块进行正确性检验的测试工作。

主要采用白盒测试方法设计测试用例，辅之以黑盒测试的测试用例。

- 模块接口测试
- 局部数据结构测试
- 路径测试
- 错误处理测试
- 边界测试

辅助模块：模拟与被测模块相联系的其他模块

- 驱动模块driver
  - 相当于被测模块的主程序，它接收测试数据并把数据传送给被测模块，最好再输出实测结果
- 桩模块stub
  - 也叫存根模块，用以代替被测模块调用的子模块

**测试环境**

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com//markdown20191118152821.png)

#### 组装测试

也叫**集成测试**或联合测试

在单元测试的基础上，将所有模块按照设计要求组装成为系统。

把模块组装为系统的方式有

- 一次性组装方式
  - 组装后再一起测试
- 增值式组装方式
  - 边组装边测试
  - 自顶向下或自底向上

自顶向下增值方式缺点是需要立桩模块

自底向上增值方式缺点是程序一直未能作为一个实体存在，直到最后才形成一个实体。

**混合增值式测试**

- 衍变的自顶向下的增值测试
- 自底向上-自顶向下的增值测试
  - 读操作子系统，自底向上
  - 写操作子系统，自顶向下
- 回归测试

#### 确认测试

又称有效性测试。验证软件功能、性能及其他特性是否与用户需求一致。

#### 系统测试

将整个系统，包括软硬件、某些支持软件、数据、人员等元素结合一起，再实际运行（使用）环境下，进行一系列的组装测试和确认测试。

## 软件维护

软件维护阶段覆盖了从软件交付使用到被淘汰的整个时期。

- 改正性维护(Corrective Maintenance)
  - 识别和纠正软件错误
- 适应性维护(Adaptive Maintenance)
  - 为了适应软件运行的外部环境或数据环境而进行的维护，以适应新的环境（网络环境或者已升级改版后的系统等）。
- 完善性维护(Perfective Maintenance)
  - 为了满足新的功能和性能要求，进行的修改或再开发软件。
  - 为了扩充软件功能、增强软件性能、改进加工效率、提高软件的可维护性。
- 预防性维护(Preventive Maintenance)

### 影响维护工作量的因素

- 系统的规模
- 程序设计语言
- 系统年龄
- 数据库技术的应用
- 先进的软件开发技术
- 其他因素
  - 应用的类型、数学模型、任务难度、嵌套深度、索引、下标数。

### 维护成本

维护工作量模型：$M = p + Ke^{c-d}$

- M：维护的总工作量
- p：生产性工作量
- K：经验常数
- c：复杂程度
- d：维护人员对软件的熟悉程度

### 维护过程

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com//markdown20191126185005.png)

### 软件可维护性

Maintainability，指理解、改正、调整和改进软件的难易程度。

**对软件可维护性影响的主要因素有**

- 可理解性(Understandability)
- 可测试性(Testability)
- 可修改性(Modifiability)
- 可移植性(Portability)

**提高可理解性的措施**

- 采用模块化的程序结构
- 书写文档
- 采用结构化程序设计
- 书写源程序的内部文档
- 使用良好的编程语言
- 具有良好的程序设计风格

**提高可测试性的措施**

- 采用良好的程序结构
- 书写文档
- 使用测试工具和调试工具
- 保存以前的测试过程和测试用例

**总的来说，提高软件可维护性，从以下几点看**

- 确定质量管理目标和优先级 Determine quality management goals and priorities
- 使用提高软件质量的技术与工具 Use technology and tools to improve software quality
- 选择可维护性高的程序设计语言 Choose a maintainable programming language
- 改进程序文档 Improved program documentation
- 进行质量保证审查 Conduct quality assurance review

## 软件再工程

### 软件重构

> 在软件工程学中重构（Refactoring）就是在不改变软件现有功能的基础上，通过调整程序代码改善软件的质量、性能，使其程序的设计模式和架构更趋合理，提高软件的扩展性和维护性。

**重构的好处**

- 能改进软件设计使软件更容易被理解（布局、命名、注释、简化逻辑等）
- 能帮你找到bug（）
- 提高软件的开发速度（改进方法，为后继开发提供优势）

**什么时候重构**

- 在添加新功能时进行重构。
- 在修改bug时进行重构。
- 在代码复审时进行重构。

## 软件项目管理

**什么是项目？**

项目是为了创造一个唯一的产品或创造一个唯一的服务而进行的临时性努力。

**什么是软件项目管理？**

为了使软件项目能够按照预定的成本、进度、质量顺利完 成，而对成本、人员、进度、质量、风险等进行分析和管理的活动。

**三角制约关系**

质量、成本、时间。

**项目管理关注的主要因素 5P**

- 人 Person
- 问题 Problem
- 产品 Product
- 过程 Produce
- 项目 Project

**项目经理与产品经理的区别**

- 产品经理关注市场、产品线、产品定位。负责产品的整个生命周期

- 项目经理 计划 组织 管理项目的所有阶段

- 项目是临时的，产品是长久的。

### 规模估算

开发时间估算方法

- 代码行技术
- 功能点技术

成本估算方法

- 专家判断
- 类比估算
- COCOMO2模型（构造性成本模型Constructive cost model）

### 软件配置管理

在软件建立时变更是不可避免的，如果不进行变更控制，可能加剧项目中的混乱。

为了协调软件开发，使混乱减到最小，使用配置管理技术，使变更所产生的错误达到最小并最有效地提高生产率。

#### 基线

> IEEE定义：已经通过了正 式复审的规格说明或中间产品，它可以作为进一步开发的基础，并且只有通过正式的变化控制过程才能改变它 。

#### 版本控制

版本控制联合使用规程和工具，以管理在软件工程过程中所创建的配置对象的不同版本。

#### 变更控制

接到变化请求后先进行评估，形成变化报告，交由审批人审阅，审批对变化的状态和优先级做最终决策。

#### 配置审计

关注被修改后的配置对象的技术正确性。审查该对象以确定它与 其他软件配置项的一致性，并检查是否有遗漏或副作用。 

#### 状态报告

为了清楚、及时地记载软件配置的变化，需要对开发的过程作出系统的记录反映开发活动的历史情况。

